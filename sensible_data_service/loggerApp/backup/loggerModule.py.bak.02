import pymongo
from utils.log_database import LogDatabase
import json
from utils import log_config as CONFIG
from Crypto.Hash import SHA512
import helperModule
import PERMISSIONS
from utils.keystore import Keystore

class Logger(object):

    logDatabase = None
    keystore = None

    def __init__(self):
        self.logDatabase = LogDatabase()
        self.keystore = Keystore()


#    def append(self, role, _username, _method, _data, _request):
    def append(self, _request, _method, _data):
        print "APPEND"
        if not (_request.user.is_authenticated()):
           return # False
        
       
        username = str(_request.user)
        returned = None
        st = helperModule.getTimestamp()
#        if (self.dispatching(role, _method)): # If the check went fine
        return getattr(self, _method)(username, _data, st) # the corresponding method gets called with data as input


# log_entry = <flowID, D, V, Z>
# D = <userID,appID,payload>
    def append_dataflow(self, _username, _data, _st):
        current_flowID = self.logDatabase.getMaxFlowID() + 1		
        current_D = helperModule.create_D(_data)
        current_V = helperModule.create_V(current_D)
        
        previous_A = self.keystore.getUserKey(_username)
        previous_Z = self.logDatabase.getPrevious(current_flowID).get("Z")
        current_Z = helperModule.create_Z(current_V, previous_Z, str(previous_A))
        
        self.keystore.update_A(_username)

        mongo_id_string = self.logDatabase.writeEntryWith_Z(current_flowID, current_D, current_V, current_Z) # Finally, writes the log entry
        return (current_flowID, mongo_id_string)



    def cryptoSetup(self):
        self.logDatabase.writeEntryWith_Z(CONFIG.FIRST_ENTRY, CONFIG.D0, CONFIG.V0, CONFIG.Z0)

    def addUserKey(self, _username, _key):
        mid = self.keystore.addUserKey(_username, _key)        
        return (mid, " ", _key)

    def appendDataFlowEvent(self, _request, _data, st):
        print _request
        return None


#    def dispatching(self,role,method):
#        granted = False
#        for case in self.switch(role):
#            if case(PERMISSIONS.USER_ID):
#                granted = self.checkPermissions(method,PERMISSIONS.USER["methods"])
#                return granted
#            if case(PERMISSIONS.ADMIN_ID):
#                granted = sel.fcheckPermissions(method,PERMISSIONS.ADMIN["methods"])
#                return granted
#            if case():
#                granted = False
#                print "The case = <" + role + "," + method + "> is not possible!"


    def checkPermissions(self, method, methodList): # reaplce with django authorization
        granted = False
        if method in methodList:
            granted = True
        else:
            granted = False
        return granted
                        

    class switch(object):
        def __init__(self, value):
            self.value = value
            self.fall = False
        def __iter__(self): 
            yield self.match
            raise StopIteration
        def match(self, *args):
            if self.fall or not args:
                return True
            elif self.value in args:
                self.fall = True
                return True
            else:
                return False




    def userRegistration(_registered, _secretKey): # _registered = True/False
        return None

    def appAuthorized(_authorized, _appName, _request):
        return None


